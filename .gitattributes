def countingSortForRadix(inputArray, placeValue):
    # We can assume that the number of digits used to represent
    # all numbers on the placeValue position is not grater than 10
    countArray = [0] * 10
    inputSize = len(inputArray)

    # placeElement is the value of the current place value
    # of the current element, e.g. if the current element is
    # 123, and the place value is 10, the placeElement is
    # equal to 2
    for i in range(inputSize):
        placeElement = (inputArray[i] // placeValue) % 10
        countArray[placeElement] += 1

    for i in range(1, 10):
        countArray[i] += countArray[i - 1]

    # Reconstructing the output array
    outputArray = [0] * inputSize
    i = inputSize - 1
    while i >= 0:
        currentEl = inputArray[i]
        placeElement = (inputArray[i] // placeValue) % 10
        countArray[placeElement] -= 1
        newPosition = countArray[placeElement]
        outputArray[newPosition] = currentEl
        i -= 1

    return outputArray


def radixSort(inputArray):
    # Step 1 -> Find the maximum element in the input array
    maxEl = max(inputArray)

    # Step 2 -> Find the number of digits in the `max` element
    D = 1
    while maxEl > 0:
        maxEl /= 10
        D += 1

    # Step 3 -> Initialize the place value to the least significant place
    placeVal = 1

    # Step 4
    outputArray = inputArray
    while D > 0:
        outputArray = countingSortForRadix(outputArray, placeVal)
        placeVal *= 10
        D -= 1

    return outputArray


def mergeSort(myList):
    if len(myList) > 1:
        mid = len(myList) // 2
        left = myList[:mid]
        right = myList[mid:]

        # Recursive call on each half
        mergeSort(left)
        mergeSort(right)

        # Two iterators for traversing the two halves
        i = 0
        j = 0

        # Iterator for the main list
        k = 0

        while i < len(left) and j < len(right):
            if left[i] <= right[j]:
                # The value from the left half has been used
                myList[k] = left[i]
                # Move the iterator forward
                i += 1
            else:
                myList[k] = right[j]
                j += 1
            # Move to the next slot
            k += 1

        # For all the remaining values
        while i < len(left):
            myList[k] = left[i]
            i += 1
            k += 1

        while j < len(right):
            myList[k] = right[j]
            j += 1
            k += 1


def shellSort(inp, n):
    h = n // 2
    while h > 0:
        for i in range(h, n):
            t = inp[i]
            j = i
            while j >= h and inp[j - h] > t:
                inp[j] = inp[j - h]
                j -= h

            inp[j] = t
        h = h // 2


def max_heapify(arr, n, i):
    l = 2 * i + 1
    r = 2 * i + 2

    if l < n and arr[l] > arr[i]:
        largest = l
    else:
        largest = i

    if r < n and arr[r] > arr[largest]:
        largest = r

    if largest != i:
        arr[i], arr[largest] = arr[largest], arr[i]
        max_heapify(arr, n, largest)


def heapSort(arr):
    n = len(arr)

    for i in range(n, -1, -1):
        max_heapify(arr, n, i)

    for i in range(n - 1, 0, -1):
        arr[0], arr[i] = arr[i], arr[0]
        max_heapify(arr, i, 0)


def countingSort(inputArray):
    # Find the maximum element in the inputArray
    maxElement= max(inputArray)

    countArrayLength = maxElement+1

    # Initialize the countArray with (max+1) zeros
    countArray = [0] * countArrayLength

    # Step 1 -> Traverse the inputArray and increase
    # the corresponding count for every element by 1
    for el in inputArray:
        countArray[el] += 1

    # Step 2 -> For each element in the countArray,
    # sum up its value with the value of the previous
    # element, and then store that value
    # as the value of the current element
    for i in range(1, countArrayLength):
        countArray[i] += countArray[i-1]

    # Step 3 -> Calculate element position
    # based on the countArray values
    outputArray = [0] * len(inputArray)
    i = len(inputArray) - 1
    while i >= 0:
        currentEl = inputArray[i]
        countArray[currentEl] -= 1
        newPosition = countArray[currentEl]
        outputArray[newPosition] = currentEl
        i -= 1

    return outputArray


import random
import time

f = open("citire3.txt")

array1 = []
t = int(f.readline())
print(f"Nr de teste care vor fi efectuate este: {t} \n")
z = 0
while z != t:
    linie = [int(a) for a in f.readline().split()]
    nr = linie[0]
    print(f"Cate numere trebuie sortate: {nr}")
    m = linie[1]
    print(f"Cea mai mare valoare pe care o poate lua un nr e: {m}\n")
    for j in range(0, nr):
        n = random.randint(1, m)
        array1.append(n)

    array2 = array1
    start = time.time()
    radixSort(array2)
    end = time.time()
    print(f"Timpul se sortare RadixSort este: {end - start}")
    # print(*array2)

    array2 = array1
    start = time.time()
    mergeSort(array2)
    end = time.time()
    print(f"Timpul se sortare MergeSort este: {end - start}")
    # print(*array2)

    array2 = array1
    start = time.time()
    shellSort(array2, nr)
    end = time.time()
    print(f"Timpul se sortare ShellSort este: {end - start}")
    # print(*array2)

    array2 = array1
    start = time.time()
    heapSort(array2)
    end = time.time()
    print(f"Timpul se sortare HeapSort este: {end - start}")
    # print(*array2)

    # array2 = array1
    start = time.time()
    array2 = countingSort(array1)
    end = time.time()
    print(f"Timpul se sortare CountingSort este: {end - start}")
    # print(*array2)

    array2 = array1
    start = time.time()
    sorted(array2, reverse=False)
    end = time.time()
    print(f"Timpul se sortarea predefinita Python este: {end - start} \n")

    print("\n")
    z += 1

f.close()
